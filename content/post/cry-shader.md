---
date: 2016-10-17
title: CryEngine и шейдера
slug: cry-shader
tags:
 - cryengine
 - pain
categories:
 - Cry Engine
menu: main
---

Имя вы не зря даёте,
Я скажут вам наперёд:
Как вы яхту назовёте,
Так она и поплывёт!
© "Приключения капитана Врунгеля"

Cry - плакать, рыдать, заплакать, поплакать, расплакаться
Engine - двигатель, мотор, движок

Небольшая история про шейдера в CryEngine. К сожалению, описанное не является исключением.

<!--more-->

### Часть первая. Туманная.

С начала использования CryEngine у нас была проблема: иногда при запуске редактора на загружаемом уровне было черным черно.

Особенно раздражал тот факт, что вероятность данного события достаточно высока: на некоторых компьтерах она была более 50%.

Проблема доставляла достаточно неудобств, чтобы начать копать в этом направлении. Опыт работы с CryEngine был крайне небольшим и от того раскопки шли медленно.

Первый раз, когда удалось целеноправленно воспроизвести проблему, первая мысль была добавить еще один источник света: я попросил помощи у дизайнера уровней и он помог мне с этим вопросом, но отображение не изменилось. За то он предложил подёргать ползунок времени суток. Внезапно, ночной уровень был светлым.

Анализ параметров, на которые влияет время суток, позволил выявить, что критичным для воспроизведения проблемы является плотность тумана.

Так же, если при наличии проблемы выключить туман, то сцена отображается нормально.

Подозрение сразу пало на шейдера.

Через многократную модификацию шейдеров, удалось выяснить, что один из параметров входной стуктуры шейдер всегда равен нулю. При этом на стороне C++ параметр был задан. То есть из C++ данные передавались, но в шейдер не попадали.

Несколько часов отладки помогли найти проблемный кусок кода:
```
        int nSize     = CHWShader_D3D::s_pCurInstVS->m_nDataSize;
        void* pVSData = CHWShader_D3D::s_pCurInstVS->m_pShaderData;
        if (FAILED(hr = GetDevice().CreateInputLayout(&Decl.m_Declaration[0], Decl.m_Declaration.Num(), pVSData, nSize, &pDeclCache->m_pDeclaration)))
        {
            return hr;
        }
```
При этом важно, что CreateInputLayout вызывался один раз на объявление структуры входных параметров (одна структура может использоваться в нескольких шейдерах). Однако, в метод CreateInputLayout явно передаётся тело шейдера, которое в ключе кэша никак не участвует.

Таким образом поведение редактора зависило от того, в каком порядке инициализируются шейдера. Так как этот процесс происходит асинхронно, проблема возникает не со 100% вероятностью.

Внезапно, код необходимый для решения проблемы уже был в CryEngine и включался define-ом `FEATURE_PER_SHADER_INPUT_LAYOUT_CACHE`. Таким образом получился фикс-однострочник (https://github.com/CRYTEK-CRYENGINE/CRYENGINE/pull/31).

После этого пришлось поправить пару шейдеров, которые до этого работали сугубо случайно, но тем не менее это решило проблему.

Особенно поразило, что данная проблема существует с CryEngine 3 и по сей день (CryEngine 5). Причины, по которой она не должна проявлять себя в собранных играх я не вижу.

### Часть вторая. Пакованная.
