---
date: 2016-07-31
title: Клавиатура
slug: keyboard
tags:
 - programming
 - keyboard
categories:
 - Programming
menu: main
---

Волей случая мне пришлось познать работу с клавиатурой в игровом проекте. Надо отметить, что тема эта оказалась не так проста и, к примеру, в Unreal Engine и Cry Engine с клавиатурой есть проблемы. Обычно их не видно, но в процессе интернационализации они проявляются очень сильно.

Далее будут использоваться термины Windows, но общая идея справедлива для всех операционных систем.

Беда в том, что для клавиатуры существует не только несколько понятий “нажатости” клавиши:

 1. клавиша физически нажата на клавиатуре (состояние клавиши по данным DirectX);
 1. пришло событие о нажатии клавиши (события WM_ из операционной системы).

Но и несколько способов идентификации клавиши:

 1. по физической позиции на клавиатуре (сканкод);
 1. по символу, который соответствует данной клавише.

<!--more-->
### Проблема идентификации клавиши

Проблема идентификации клавиши возникает из-за существования нескольких раскладок. При этом важно осознавать, что не на всех этих раскладках латинские буквы находятся в одном и том же месте.

К примеру, на французской раскладке кнопки WASD находятся не там, где мы их привыкли видеть.

Хуже того, я технически могу переключать клавиатуру между AZERTY и QWERTY раскладкой на лету.

То есть кнопки, привязанные к месторасположению, должны быть назначены через сканкод.

Если предусмотрено переназначение клавиш, то ИМХО надо выводить в окне настроек символы, соответствующие этим клавишам в **текущей** раскладке. Если пользователь сменил раскладку, то должны смениться и отображаемые символы.

### Разные понятия "нажатости" клавиш

Разные понятия "нажатости" клавиш появляются от того, что ожидаемое поведение клавиш в игре сильно контрастирует с тем, как они себя ведут в интерфейсе и особенно в полях ввода.

В игре, в первую очередь, важен факт нажатости клавиши на момент начала кадра. Так же крайне важно узнать о том, что её отпустили, даже если было переключение на другое приложение. Из-за этого удобнее всего проверять состояния клавиш через DirectX Input.

В интерфейсе все несколько сложнее, особенно если есть различные поля ввода: нужно делить клавиатуру вместе со сторонними подстстемами, например: оверлеи и системы ввода иероглифов (IME). При этом если в случае с оверлеями можно заявить, что они просто не поддерживаются, то поддержка IME является обязательным условием для выхода на некоторые азиатские рынки.

В этом случае при работе с клавиатурой важен не только факт нажатия клавиши, но и то, в контексте какой подсистемы она должна быть обработана. В этом случае необходимо работать на основании событий от операционной системы. В противном случае можно получить неожиданное поведение таких клавиш как Esc, Backspace и Enter.

Для примера: в случае, если во время IME нажать Backspace, то эта клавиша будет обработана на стороне IME и событие WM_KEYDOWN в приложение отправлено не будет, хотя DirectX Input будет считать клавишу нажатой.
Если при этом поле ввода будет использовать данные от DirectX, то поведение его будет не корректным.

### Резюмируя

Подводя итог хочется сказать:

 1. Если важно физическое расположение клавиш, то предпочтительнее использовать сканкод.
 1. Для интерфейса предпочтительнее использовать системные события.
 1. Существуют и используются раскладки, отличные от QWERTY.
 1. IME сулит много проблем. Там действительно водятся драконы.
